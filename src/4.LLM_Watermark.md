# 電子透かしとは？

とりあえず、実例を見てみよう。プロンプトとして、「『自由』は何ですか？」を与えて、以下の二通りの答えが作れます。
```
(Sample 1) “自由”という言葉は、非常に幅広い意味を持つ概念です。それは、道徳的・法的・または社会的に独立した状態を指し、自分の意思に基づいて行動したり、意見を表明したり、好きなように生きることを意味します。それは、抑圧や制限を受けない場所であると同時に、自分の人生を選択し、価値観に基づいて行動できる状態とも言えます。さらに、個人的な意思決定、経済的な自由、そして他人に対する自由といった、様々な形で「自由」は定義されることがあります。<end_of_turn>

(Sample 2)「自由」とは、自律的な意思決定や行動の自由、そして、自分の人生や選択の主導権を持つことです。それは単なる物理的な自由だけでなく、抑圧や制限を受けない状態、自分の価値観や信念に基づいて行動できる能力、そして、自分の人生の方向性や目指すものを自由に設定する力を含んでいます。<end_of_turn>
```
それでがクイズです、この二つのサンプルで、どれが電子透かしが入っているでしょう。
![](../pics/思考.png)


答えを開示します：両方とも透かしが入っています。

---

![](../pics/ショック.png)

なんでやねん、と思った方は少々弁明を聞いてほしいです。

ちゃんと透かしが入れていないサンプルが用意しているから
```
(Sample W/O. WM) “自由”とは、単なる「良い状態」や「良い結果」を示す言葉ではなく、非常に広い意味を持つ概念です。それは、自分の意志で行動できること、考えや感情に基づいて自由に選択できること、そして、制限や束縛から解放された状態を指します。それは、自己決定権、表現の自由、社会における公正な地位、そして、自分の人生の道を選べる権利を含む様々な側面を包含しています。<end_of_turn>
```

透かしと言えば、普段よく考えられるのは、画像でマークをこまめに入れるものでしょう。言語の場合そうはいかない、なぜなら、言語の有用性を損なうし、同じパターンを何度でも入れるのは除去するのもたやすいです。何より、こういうシンプルなパターンが一端観察された次第、偽るもたやすいでしょう。

ここで、透かしのいくつかの重要な性質が見えてきました。第一、簡単に見つからないこと。第二、簡単に偽造されないこと。


上の例を目にした皆さんは多分、第一の性質がどうやって実現しているのかを気になっているところだと思うので、さっそく種明かしをしましょう。


## 偏りのある単語帳

この前に説明した、トークンはLLMの単語という比喩を思い出してほしいです。
高校の時、みんな自分の好きな単語帳を使い、英語力を身に着けると思います。
その時、使っている単語帳により、記憶した単語ももちろん偏りが出できます。
例えば、『シス単』の中に「diameter（直径）」という単語があって、しかし『ターゲット1900』にはそれがありません。
クラスの中に、もし「diameter」という単語を知っている学生がいれば、この学生は必ず『ターゲット1900』しか使っていないということを断言できます。

LLM透かしはこの原理を活用して、偏りのある単語帳を作り出すのは第一歩です。
しかし、Tokenizerの話をまだ忘れていない方はここに疑問があるかもしれない。
LLMのTokenizerは与えられたテキストで計算されたもので、その中に何かを足してあるいは消すのは、元のデータの調整を意味する。
しかし、これは元のテキストの品質を損なう行為でもあります。

そこに注目した方はご明察です。
そもそも、訓練済みのモデルのTokenizerを調整するのは現実ではありません。
そこで使われている手法は、**トークンの振り分け**です。
例えば、二つのグループに振り分けます。
全てのトークンを、赤いトークンと緑のトークンに乱数的に振り分けることにより、もともとのトークンの集合（単語帳）が、重なりのない二つの部分集合に分けることができます。

![division.svg](../pics/division.svg)

乱数的の振り分けのため、この分け方そのものが単語帳の特性となります。
疑似乱数の性質上、分け方は乱数シードと入力するトークンリストの長さしか依存していません。
そのため、シードを暗証キーとする場合、シード無しで分け方を当てるのは至難の業です。
**もしある文書の中に、緑の単語の数が、著しく赤い単語の数を上回っているとわかったら、それが暗証キーを知っているということを意味する。**

したがって、モデルの単語帳をこうやって振り分けることより、「偏り」を作れるというわけです。それでは、コードとして、どのようなものになるのか、見てみましょう。

とりあえず、乱数的にトークンを選ぶための関数を作ります：
```python
def get_unique_random_numbers(start, stop, n, seed = 114514):
  """startからstopまでの区間の中に、乱数的にn個の整数を選ぶ
  """
  population_size = stop - start
  if n > population_size:
    raise ValueError(f"区間の長さ{population_size}はn ({n})以下")
  
  # ここでseedを設置すると、何度この関数を回すでも、結果は変わらないようにする
  random.seed(seed)
  return sorted(random.sample(range(start, stop), n))
```
この関数を試してみよう：
```python
random_list_1 = get_unique_random_numbers(0, 1000, 5, seed = 114)
random_list_2 = get_unique_random_numbers(0, 1000, 5, seed = 514)
print("リスト1:" ,random_list_1)
print("リスト2:" ,random_list_2)
```
そして、出力として:
```
リスト1: [100, 246, 344, 576, 681]
リスト2: [112, 213, 366, 647, 669]
```
確か異なるseedに応じて、乱数的ぽく数字を選んでくれましたね。この関数の性質上、これからseedを明示的に設定しなくでも、デフォルトに114514になります。

これをトークンのリストのサイズに適用したいところだが、そうは安直に行けません。よくトークンリストの中身を見ると、いくつかの特殊トークンが目にします。gemmaのコンフィグファイルをよく読むと、普通のトークンは第237番から始め、255968目で終わります。特殊トークンを除外するため、このように実装します：
```python
# 緑と赤いのトークンの割合を半々にし
green_red_list_ratio = 0.5

meaningful_start_at = 237
meaningful_end_at = 255968

len_meaningful = meaningful_end_at - meaningful_start_at

len_green_list = int(green_red_list_ratio * len_meaningful)
print(f"トークンの総数：{tokenizer.vocab_size}")
print(f"意味のあるトークンの総数：{len_meaningful}")
print(f"そのうち緑のトークンの数は{len_green_list}")
```
これをもって、いよいよ緑のトークンリストを作れます：
```python
green_ids = get_unique_random_numbers(
    start = meaningful_start_at,
    stop  = meaningful_end_at, 
    n = len_meaningful
)
```

そして、緑と赤いのトークンリストが一体どのように振り分けるのかを確認しましょう：



![](../pics/simple_vis.svg)

